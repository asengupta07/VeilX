"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_thirdweb_dist_esm_wallets_injected_index_js"],{

/***/ "(app-pages-browser)/./node_modules/thirdweb/dist/esm/wallets/injected/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/wallets/injected/index.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoConnectInjectedWallet: function() { return /* binding */ autoConnectInjectedWallet; },\n/* harmony export */   connectInjectedWallet: function() { return /* binding */ connectInjectedWallet; },\n/* harmony export */   getInjectedProvider: function() { return /* binding */ getInjectedProvider; },\n/* harmony export */   isInjectedWallet: function() { return /* binding */ isInjectedWallet; }\n/* harmony export */ });\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! viem */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/typedData.js\");\n/* harmony import */ var _chains_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../chains/utils.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/chains/utils.js\");\n/* harmony import */ var _utils_address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/address.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/address.js\");\n/* harmony import */ var _utils_encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/encoding/hex.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/encoding/hex.js\");\n/* harmony import */ var _utils_chains_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/chains.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/wallets/utils/chains.js\");\n/* harmony import */ var _utils_normalizeChainId_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/normalizeChainId.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/wallets/utils/normalizeChainId.js\");\n/* harmony import */ var _mipdStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mipdStore.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/wallets/injected/mipdStore.js\");\n/* harmony import */ var _utils_signatures_helpers_parseTypedData_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/signatures/helpers/parseTypedData.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/signatures/helpers/parseTypedData.js\");\n\n\n\n\n\n\n\n\n/**\n * Checks if the provided wallet is an injected wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is an injected wallet, false otherwise.\n */\nfunction isInjectedWallet(wallet) {\n    return !!(0,_mipdStore_js__WEBPACK_IMPORTED_MODULE_0__.injectedProvider)(wallet.id);\n}\n// TODO: save the provider in data\nfunction getInjectedProvider(walletId) {\n    const provider = (0,_mipdStore_js__WEBPACK_IMPORTED_MODULE_0__.injectedProvider)(walletId);\n    if (!provider) {\n        throw new Error(`No injected provider found for wallet: \"${walletId}\"`);\n    }\n    return provider;\n}\n/**\n * @internal\n */\nasync function connectInjectedWallet(id, options, emitter) {\n    const provider = getInjectedProvider(id);\n    const addresses = await provider.request({\n        method: \"eth_requestAccounts\",\n    });\n    const addr = addresses[0];\n    if (!addr) {\n        throw new Error(\"no accounts available\");\n    }\n    // use the first account\n    const address = (0,_utils_address_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(addr);\n    // get the chainId the provider is on\n    const chainId = await provider\n        .request({ method: \"eth_chainId\" })\n        .then(_utils_normalizeChainId_js__WEBPACK_IMPORTED_MODULE_2__.normalizeChainId);\n    let connectedChain = options.chain && options.chain.id === chainId\n        ? options.chain\n        : (0,_chains_utils_js__WEBPACK_IMPORTED_MODULE_3__.getCachedChain)(chainId);\n    // if we want a specific chainId and it is not the same as the provider chainId, trigger switchChain\n    if (options.chain && options.chain.id !== chainId) {\n        await switchChain(provider, options.chain);\n        connectedChain = options.chain;\n    }\n    return onConnect(provider, address, connectedChain, emitter);\n}\n/**\n * @internal\n */\nasync function autoConnectInjectedWallet(id, emitter, chain) {\n    const provider = getInjectedProvider(id);\n    // connected accounts\n    const addresses = await provider.request({\n        method: \"eth_accounts\",\n    });\n    const addr = addresses[0];\n    if (!addr) {\n        throw new Error(\"no accounts available\");\n    }\n    // use the first account\n    const address = (0,_utils_address_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(addr);\n    // get the chainId the provider is on\n    const chainId = await provider\n        .request({ method: \"eth_chainId\" })\n        .then(_utils_normalizeChainId_js__WEBPACK_IMPORTED_MODULE_2__.normalizeChainId);\n    const connectedChain = chain && chain.id === chainId ? chain : (0,_chains_utils_js__WEBPACK_IMPORTED_MODULE_3__.getCachedChain)(chainId);\n    return onConnect(provider, address, connectedChain, emitter);\n}\nfunction createAccount(provider, _address) {\n    const account = {\n        address: (0,_utils_address_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(_address),\n        async sendTransaction(tx) {\n            const transactionHash = (await provider.request({\n                method: \"eth_sendTransaction\",\n                params: [\n                    {\n                        accessList: tx.accessList,\n                        value: tx.value ? (0,_utils_encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__.numberToHex)(tx.value) : undefined,\n                        gas: tx.gas ? (0,_utils_encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__.numberToHex)(tx.gas) : undefined,\n                        from: this.address,\n                        to: tx.to,\n                        data: tx.data,\n                    },\n                ],\n            }));\n            return {\n                transactionHash,\n            };\n        },\n        async signMessage({ message }) {\n            if (!account.address) {\n                throw new Error(\"Provider not setup\");\n            }\n            const messageToSign = (() => {\n                if (typeof message === \"string\") {\n                    return (0,_utils_encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__.stringToHex)(message);\n                }\n                if (message.raw instanceof Uint8Array) {\n                    return (0,_utils_encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__.uint8ArrayToHex)(message.raw);\n                }\n                return message.raw;\n            })();\n            return await provider.request({\n                method: \"personal_sign\",\n                params: [messageToSign, account.address],\n            });\n        },\n        async signTypedData(typedData) {\n            if (!provider || !account.address) {\n                throw new Error(\"Provider not setup\");\n            }\n            const parsedTypedData = (0,_utils_signatures_helpers_parseTypedData_js__WEBPACK_IMPORTED_MODULE_5__.parseTypedData)(typedData);\n            const { domain, message, primaryType } = parsedTypedData;\n            const types = {\n                EIP712Domain: (0,viem__WEBPACK_IMPORTED_MODULE_6__.getTypesForEIP712Domain)({ domain }),\n                ...parsedTypedData.types,\n            };\n            // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n            // as we can't statically check this with TypeScript.\n            (0,viem__WEBPACK_IMPORTED_MODULE_6__.validateTypedData)({ domain, message, primaryType, types });\n            const stringifiedData = (0,viem__WEBPACK_IMPORTED_MODULE_6__.serializeTypedData)({\n                domain: domain ?? {},\n                message,\n                primaryType,\n                types,\n            });\n            return await provider.request({\n                method: \"eth_signTypedData_v4\",\n                params: [account.address, stringifiedData],\n            });\n        },\n        async watchAsset(asset) {\n            const result = await provider.request({\n                method: \"wallet_watchAsset\",\n                params: asset,\n            }, { retryCount: 0 });\n            return result;\n        },\n    };\n    return account;\n}\n/**\n * Call this method when the wallet provider is connected or auto connected\n * @internal\n */\nasync function onConnect(provider, address, chain, emitter) {\n    const account = createAccount(provider, address);\n    async function disconnect() {\n        provider.removeListener(\"accountsChanged\", onAccountsChanged);\n        provider.removeListener(\"chainChanged\", onChainChanged);\n        provider.removeListener(\"disconnect\", onDisconnect);\n    }\n    async function onDisconnect() {\n        disconnect();\n        emitter.emit(\"disconnect\", undefined);\n    }\n    function onAccountsChanged(accounts) {\n        if (accounts[0]) {\n            const newAccount = createAccount(provider, (0,_utils_address_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(accounts[0]));\n            emitter.emit(\"accountChanged\", newAccount);\n            emitter.emit(\"accountsChanged\", accounts);\n        }\n        else {\n            onDisconnect();\n        }\n    }\n    function onChainChanged(newChainId) {\n        const newChain = (0,_chains_utils_js__WEBPACK_IMPORTED_MODULE_3__.getCachedChain)((0,_utils_normalizeChainId_js__WEBPACK_IMPORTED_MODULE_2__.normalizeChainId)(newChainId));\n        emitter.emit(\"chainChanged\", newChain);\n    }\n    if (provider.on) {\n        provider.on(\"accountsChanged\", onAccountsChanged);\n        provider.on(\"chainChanged\", onChainChanged);\n        provider.on(\"disconnect\", onDisconnect);\n    }\n    return [\n        account,\n        chain,\n        onDisconnect,\n        (newChain) => switchChain(provider, newChain),\n    ];\n}\n/**\n * @internal\n */\nasync function switchChain(provider, chain) {\n    const hexChainId = (0,_utils_encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__.numberToHex)(chain.id);\n    try {\n        await provider.request({\n            method: \"wallet_switchEthereumChain\",\n            params: [{ chainId: hexChainId }],\n        });\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n    }\n    catch (e) {\n        // if chain does not exist, add the chain\n        if (e?.code === 4902 || e?.data?.originalError?.code === 4902) {\n            const apiChain = await (0,_chains_utils_js__WEBPACK_IMPORTED_MODULE_3__.getChainMetadata)(chain);\n            await provider.request({\n                method: \"wallet_addEthereumChain\",\n                params: [\n                    {\n                        chainId: hexChainId,\n                        chainName: apiChain.name,\n                        nativeCurrency: apiChain.nativeCurrency,\n                        rpcUrls: (0,_utils_chains_js__WEBPACK_IMPORTED_MODULE_7__.getValidPublicRPCUrl)(apiChain), // no client id on purpose here\n                        blockExplorerUrls: apiChain.explorers?.map((x) => x.url),\n                    },\n                ],\n            });\n        }\n        else {\n            throw e;\n        }\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS93YWxsZXRzL2luamVjdGVkL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUF1RjtBQUNkO0FBQ3JCO0FBQ3FDO0FBQy9CO0FBQ007QUFDZDtBQUNnQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGFBQWEsK0RBQWdCO0FBQzdCO0FBQ0E7QUFDTztBQUNQLHFCQUFxQiwrREFBZ0I7QUFDckM7QUFDQSxtRUFBbUUsU0FBUztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZEQUFVO0FBQzlCO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDLGNBQWMsd0VBQWdCO0FBQzlCO0FBQ0E7QUFDQSxVQUFVLGdFQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZEQUFVO0FBQzlCO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDLGNBQWMsd0VBQWdCO0FBQzlCLG1FQUFtRSxnRUFBYztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2REFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbUVBQVc7QUFDckQsc0NBQXNDLG1FQUFXO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtRUFBVztBQUN0QztBQUNBO0FBQ0EsMkJBQTJCLHVFQUFlO0FBQzFDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywyRkFBYztBQUNsRCxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0EsOEJBQThCLDZEQUF1QixHQUFHLFFBQVE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVEQUFpQixHQUFHLHFDQUFxQztBQUNyRSxvQ0FBb0Msd0RBQWtCO0FBQ3RELG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSSxlQUFlO0FBQ2hDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsNkRBQVU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnRUFBYyxDQUFDLDRFQUFnQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUVBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrRUFBZ0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0VBQW9CO0FBQ3JEO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS93YWxsZXRzL2luamVjdGVkL2luZGV4LmpzPzNjMDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0VHlwZXNGb3JFSVA3MTJEb21haW4sIHNlcmlhbGl6ZVR5cGVkRGF0YSwgdmFsaWRhdGVUeXBlZERhdGEsIH0gZnJvbSBcInZpZW1cIjtcbmltcG9ydCB7IGdldENhY2hlZENoYWluLCBnZXRDaGFpbk1ldGFkYXRhIH0gZnJvbSBcIi4uLy4uL2NoYWlucy91dGlscy5qc1wiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi8uLi91dGlscy9hZGRyZXNzLmpzXCI7XG5pbXBvcnQgeyBudW1iZXJUb0hleCwgc3RyaW5nVG9IZXgsIHVpbnQ4QXJyYXlUb0hleCwgfSBmcm9tIFwiLi4vLi4vdXRpbHMvZW5jb2RpbmcvaGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRWYWxpZFB1YmxpY1JQQ1VybCB9IGZyb20gXCIuLi91dGlscy9jaGFpbnMuanNcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZUNoYWluSWQgfSBmcm9tIFwiLi4vdXRpbHMvbm9ybWFsaXplQ2hhaW5JZC5qc1wiO1xuaW1wb3J0IHsgaW5qZWN0ZWRQcm92aWRlciB9IGZyb20gXCIuL21pcGRTdG9yZS5qc1wiO1xuaW1wb3J0IHsgcGFyc2VUeXBlZERhdGEgfSBmcm9tIFwiLi4vLi4vdXRpbHMvc2lnbmF0dXJlcy9oZWxwZXJzL3BhcnNlVHlwZWREYXRhLmpzXCI7XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgd2FsbGV0IGlzIGFuIGluamVjdGVkIHdhbGxldC5cbiAqXG4gKiBAcGFyYW0gd2FsbGV0IC0gVGhlIHdhbGxldCB0byBjaGVjay5cbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHdhbGxldCBpcyBhbiBpbmplY3RlZCB3YWxsZXQsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSW5qZWN0ZWRXYWxsZXQod2FsbGV0KSB7XG4gICAgcmV0dXJuICEhaW5qZWN0ZWRQcm92aWRlcih3YWxsZXQuaWQpO1xufVxuLy8gVE9ETzogc2F2ZSB0aGUgcHJvdmlkZXIgaW4gZGF0YVxuZXhwb3J0IGZ1bmN0aW9uIGdldEluamVjdGVkUHJvdmlkZXIod2FsbGV0SWQpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IGluamVjdGVkUHJvdmlkZXIod2FsbGV0SWQpO1xuICAgIGlmICghcHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBpbmplY3RlZCBwcm92aWRlciBmb3VuZCBmb3Igd2FsbGV0OiBcIiR7d2FsbGV0SWR9XCJgKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3ZpZGVyO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbm5lY3RJbmplY3RlZFdhbGxldChpZCwgb3B0aW9ucywgZW1pdHRlcikge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0SW5qZWN0ZWRQcm92aWRlcihpZCk7XG4gICAgY29uc3QgYWRkcmVzc2VzID0gYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogXCJldGhfcmVxdWVzdEFjY291bnRzXCIsXG4gICAgfSk7XG4gICAgY29uc3QgYWRkciA9IGFkZHJlc3Nlc1swXTtcbiAgICBpZiAoIWFkZHIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gYWNjb3VudHMgYXZhaWxhYmxlXCIpO1xuICAgIH1cbiAgICAvLyB1c2UgdGhlIGZpcnN0IGFjY291bnRcbiAgICBjb25zdCBhZGRyZXNzID0gZ2V0QWRkcmVzcyhhZGRyKTtcbiAgICAvLyBnZXQgdGhlIGNoYWluSWQgdGhlIHByb3ZpZGVyIGlzIG9uXG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHByb3ZpZGVyXG4gICAgICAgIC5yZXF1ZXN0KHsgbWV0aG9kOiBcImV0aF9jaGFpbklkXCIgfSlcbiAgICAgICAgLnRoZW4obm9ybWFsaXplQ2hhaW5JZCk7XG4gICAgbGV0IGNvbm5lY3RlZENoYWluID0gb3B0aW9ucy5jaGFpbiAmJiBvcHRpb25zLmNoYWluLmlkID09PSBjaGFpbklkXG4gICAgICAgID8gb3B0aW9ucy5jaGFpblxuICAgICAgICA6IGdldENhY2hlZENoYWluKGNoYWluSWQpO1xuICAgIC8vIGlmIHdlIHdhbnQgYSBzcGVjaWZpYyBjaGFpbklkIGFuZCBpdCBpcyBub3QgdGhlIHNhbWUgYXMgdGhlIHByb3ZpZGVyIGNoYWluSWQsIHRyaWdnZXIgc3dpdGNoQ2hhaW5cbiAgICBpZiAob3B0aW9ucy5jaGFpbiAmJiBvcHRpb25zLmNoYWluLmlkICE9PSBjaGFpbklkKSB7XG4gICAgICAgIGF3YWl0IHN3aXRjaENoYWluKHByb3ZpZGVyLCBvcHRpb25zLmNoYWluKTtcbiAgICAgICAgY29ubmVjdGVkQ2hhaW4gPSBvcHRpb25zLmNoYWluO1xuICAgIH1cbiAgICByZXR1cm4gb25Db25uZWN0KHByb3ZpZGVyLCBhZGRyZXNzLCBjb25uZWN0ZWRDaGFpbiwgZW1pdHRlcik7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXV0b0Nvbm5lY3RJbmplY3RlZFdhbGxldChpZCwgZW1pdHRlciwgY2hhaW4pIHtcbiAgICBjb25zdCBwcm92aWRlciA9IGdldEluamVjdGVkUHJvdmlkZXIoaWQpO1xuICAgIC8vIGNvbm5lY3RlZCBhY2NvdW50c1xuICAgIGNvbnN0IGFkZHJlc3NlcyA9IGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6IFwiZXRoX2FjY291bnRzXCIsXG4gICAgfSk7XG4gICAgY29uc3QgYWRkciA9IGFkZHJlc3Nlc1swXTtcbiAgICBpZiAoIWFkZHIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gYWNjb3VudHMgYXZhaWxhYmxlXCIpO1xuICAgIH1cbiAgICAvLyB1c2UgdGhlIGZpcnN0IGFjY291bnRcbiAgICBjb25zdCBhZGRyZXNzID0gZ2V0QWRkcmVzcyhhZGRyKTtcbiAgICAvLyBnZXQgdGhlIGNoYWluSWQgdGhlIHByb3ZpZGVyIGlzIG9uXG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHByb3ZpZGVyXG4gICAgICAgIC5yZXF1ZXN0KHsgbWV0aG9kOiBcImV0aF9jaGFpbklkXCIgfSlcbiAgICAgICAgLnRoZW4obm9ybWFsaXplQ2hhaW5JZCk7XG4gICAgY29uc3QgY29ubmVjdGVkQ2hhaW4gPSBjaGFpbiAmJiBjaGFpbi5pZCA9PT0gY2hhaW5JZCA/IGNoYWluIDogZ2V0Q2FjaGVkQ2hhaW4oY2hhaW5JZCk7XG4gICAgcmV0dXJuIG9uQ29ubmVjdChwcm92aWRlciwgYWRkcmVzcywgY29ubmVjdGVkQ2hhaW4sIGVtaXR0ZXIpO1xufVxuZnVuY3Rpb24gY3JlYXRlQWNjb3VudChwcm92aWRlciwgX2FkZHJlc3MpIHtcbiAgICBjb25zdCBhY2NvdW50ID0ge1xuICAgICAgICBhZGRyZXNzOiBnZXRBZGRyZXNzKF9hZGRyZXNzKSxcbiAgICAgICAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbkhhc2ggPSAoYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9zZW5kVHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzTGlzdDogdHguYWNjZXNzTGlzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0eC52YWx1ZSA/IG51bWJlclRvSGV4KHR4LnZhbHVlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhczogdHguZ2FzID8gbnVtYmVyVG9IZXgodHguZ2FzKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiB0eC50byxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHR4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgc2lnbk1lc3NhZ2UoeyBtZXNzYWdlIH0pIHtcbiAgICAgICAgICAgIGlmICghYWNjb3VudC5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZXIgbm90IHNldHVwXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZVRvU2lnbiA9ICgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdUb0hleChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UucmF3IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdWludDhBcnJheVRvSGV4KG1lc3NhZ2UucmF3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2UucmF3O1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwicGVyc29uYWxfc2lnblwiLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW21lc3NhZ2VUb1NpZ24sIGFjY291bnQuYWRkcmVzc10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgc2lnblR5cGVkRGF0YSh0eXBlZERhdGEpIHtcbiAgICAgICAgICAgIGlmICghcHJvdmlkZXIgfHwgIWFjY291bnQuYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVyIG5vdCBzZXR1cFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFR5cGVkRGF0YSA9IHBhcnNlVHlwZWREYXRhKHR5cGVkRGF0YSk7XG4gICAgICAgICAgICBjb25zdCB7IGRvbWFpbiwgbWVzc2FnZSwgcHJpbWFyeVR5cGUgfSA9IHBhcnNlZFR5cGVkRGF0YTtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVzID0ge1xuICAgICAgICAgICAgICAgIEVJUDcxMkRvbWFpbjogZ2V0VHlwZXNGb3JFSVA3MTJEb21haW4oeyBkb21haW4gfSksXG4gICAgICAgICAgICAgICAgLi4ucGFyc2VkVHlwZWREYXRhLnR5cGVzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gZG8gYSBydW50aW1lIHZhbGlkYXRpb24gY2hlY2sgb24gYWRkcmVzc2VzLCBieXRlIHJhbmdlcywgaW50ZWdlciByYW5nZXMsIGV0Y1xuICAgICAgICAgICAgLy8gYXMgd2UgY2FuJ3Qgc3RhdGljYWxseSBjaGVjayB0aGlzIHdpdGggVHlwZVNjcmlwdC5cbiAgICAgICAgICAgIHZhbGlkYXRlVHlwZWREYXRhKHsgZG9tYWluLCBtZXNzYWdlLCBwcmltYXJ5VHlwZSwgdHlwZXMgfSk7XG4gICAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZERhdGEgPSBzZXJpYWxpemVUeXBlZERhdGEoe1xuICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluID8/IHt9LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgcHJpbWFyeVR5cGUsXG4gICAgICAgICAgICAgICAgdHlwZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX3NpZ25UeXBlZERhdGFfdjRcIixcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFthY2NvdW50LmFkZHJlc3MsIHN0cmluZ2lmaWVkRGF0YV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgd2F0Y2hBc3NldChhc3NldCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIndhbGxldF93YXRjaEFzc2V0XCIsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBhc3NldCxcbiAgICAgICAgICAgIH0sIHsgcmV0cnlDb3VudDogMCB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gYWNjb3VudDtcbn1cbi8qKlxuICogQ2FsbCB0aGlzIG1ldGhvZCB3aGVuIHRoZSB3YWxsZXQgcHJvdmlkZXIgaXMgY29ubmVjdGVkIG9yIGF1dG8gY29ubmVjdGVkXG4gKiBAaW50ZXJuYWxcbiAqL1xuYXN5bmMgZnVuY3Rpb24gb25Db25uZWN0KHByb3ZpZGVyLCBhZGRyZXNzLCBjaGFpbiwgZW1pdHRlcikge1xuICAgIGNvbnN0IGFjY291bnQgPSBjcmVhdGVBY2NvdW50KHByb3ZpZGVyLCBhZGRyZXNzKTtcbiAgICBhc3luYyBmdW5jdGlvbiBkaXNjb25uZWN0KCkge1xuICAgICAgICBwcm92aWRlci5yZW1vdmVMaXN0ZW5lcihcImFjY291bnRzQ2hhbmdlZFwiLCBvbkFjY291bnRzQ2hhbmdlZCk7XG4gICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKFwiY2hhaW5DaGFuZ2VkXCIsIG9uQ2hhaW5DaGFuZ2VkKTtcbiAgICAgICAgcHJvdmlkZXIucmVtb3ZlTGlzdGVuZXIoXCJkaXNjb25uZWN0XCIsIG9uRGlzY29ubmVjdCk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIG9uRGlzY29ubmVjdCgpIHtcbiAgICAgICAgZGlzY29ubmVjdCgpO1xuICAgICAgICBlbWl0dGVyLmVtaXQoXCJkaXNjb25uZWN0XCIsIHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQWNjb3VudHNDaGFuZ2VkKGFjY291bnRzKSB7XG4gICAgICAgIGlmIChhY2NvdW50c1swXSkge1xuICAgICAgICAgICAgY29uc3QgbmV3QWNjb3VudCA9IGNyZWF0ZUFjY291bnQocHJvdmlkZXIsIGdldEFkZHJlc3MoYWNjb3VudHNbMF0pKTtcbiAgICAgICAgICAgIGVtaXR0ZXIuZW1pdChcImFjY291bnRDaGFuZ2VkXCIsIG5ld0FjY291bnQpO1xuICAgICAgICAgICAgZW1pdHRlci5lbWl0KFwiYWNjb3VudHNDaGFuZ2VkXCIsIGFjY291bnRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9uRGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQ2hhaW5DaGFuZ2VkKG5ld0NoYWluSWQpIHtcbiAgICAgICAgY29uc3QgbmV3Q2hhaW4gPSBnZXRDYWNoZWRDaGFpbihub3JtYWxpemVDaGFpbklkKG5ld0NoYWluSWQpKTtcbiAgICAgICAgZW1pdHRlci5lbWl0KFwiY2hhaW5DaGFuZ2VkXCIsIG5ld0NoYWluKTtcbiAgICB9XG4gICAgaWYgKHByb3ZpZGVyLm9uKSB7XG4gICAgICAgIHByb3ZpZGVyLm9uKFwiYWNjb3VudHNDaGFuZ2VkXCIsIG9uQWNjb3VudHNDaGFuZ2VkKTtcbiAgICAgICAgcHJvdmlkZXIub24oXCJjaGFpbkNoYW5nZWRcIiwgb25DaGFpbkNoYW5nZWQpO1xuICAgICAgICBwcm92aWRlci5vbihcImRpc2Nvbm5lY3RcIiwgb25EaXNjb25uZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAgYWNjb3VudCxcbiAgICAgICAgY2hhaW4sXG4gICAgICAgIG9uRGlzY29ubmVjdCxcbiAgICAgICAgKG5ld0NoYWluKSA9PiBzd2l0Y2hDaGFpbihwcm92aWRlciwgbmV3Q2hhaW4pLFxuICAgIF07XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5hc3luYyBmdW5jdGlvbiBzd2l0Y2hDaGFpbihwcm92aWRlciwgY2hhaW4pIHtcbiAgICBjb25zdCBoZXhDaGFpbklkID0gbnVtYmVyVG9IZXgoY2hhaW4uaWQpO1xuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgbWV0aG9kOiBcIndhbGxldF9zd2l0Y2hFdGhlcmV1bUNoYWluXCIsXG4gICAgICAgICAgICBwYXJhbXM6IFt7IGNoYWluSWQ6IGhleENoYWluSWQgfV0sXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9zdXNwaWNpb3VzL25vRXhwbGljaXRBbnk6IFRPRE86IGZpeCBhbnlcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaWYgY2hhaW4gZG9lcyBub3QgZXhpc3QsIGFkZCB0aGUgY2hhaW5cbiAgICAgICAgaWYgKGU/LmNvZGUgPT09IDQ5MDIgfHwgZT8uZGF0YT8ub3JpZ2luYWxFcnJvcj8uY29kZSA9PT0gNDkwMikge1xuICAgICAgICAgICAgY29uc3QgYXBpQ2hhaW4gPSBhd2FpdCBnZXRDaGFpbk1ldGFkYXRhKGNoYWluKTtcbiAgICAgICAgICAgIGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJ3YWxsZXRfYWRkRXRoZXJldW1DaGFpblwiLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBoZXhDaGFpbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5OYW1lOiBhcGlDaGFpbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmF0aXZlQ3VycmVuY3k6IGFwaUNoYWluLm5hdGl2ZUN1cnJlbmN5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcnBjVXJsczogZ2V0VmFsaWRQdWJsaWNSUENVcmwoYXBpQ2hhaW4pLCAvLyBubyBjbGllbnQgaWQgb24gcHVycG9zZSBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja0V4cGxvcmVyVXJsczogYXBpQ2hhaW4uZXhwbG9yZXJzPy5tYXAoKHgpID0+IHgudXJsKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/thirdweb/dist/esm/wallets/injected/index.js\n"));

/***/ })

}]);